<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kanu Revenue</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
<style>
  :root {
    --primary-color: #2A52BE;
    --secondary-color: #d5e3e8;
    --clinic-color: #FFBF65;
    --aqua-color: #BDD7BF;
    --border-color: #ccc;
    --negative-color: red;
    --totals-color: blue;
    --table-header-color: green;
    --modal-bg: rgba(0, 0, 0, 0.5);
  }

  body { 
    font-family: 'Arial Narrow', sans-serif; 
    margin: 20px;
    line-height: 1.6;
  }

  h1 {
    color: var(--primary-color);
    font-size: 2em;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    margin-bottom: off;
  }

  h4 {
    color: red;
  }

  .dashboard-container {
    max-width: 1200px;
    margin: 0 auto;
  }

  .filters {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-bottom: 30px;
    padding: 15px;
    background-color: #f5f5f5;
    border-radius: 5px;
  }

  .filter-group {
    display: flex;
    flex-direction: column;
    min-width: 200px;
  }

  label {
    margin-bottom: 5px;
    font-weight: bold;
  }

  select, input {
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
  }

  .radio-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }

  .divider {
    height: 2px;
    background-color: #ccc;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin: 40px 0;
  }

  .totals {
    margin-bottom: 30px;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 30px;
  }

  th, td {
    border: 1px solid var(--border-color);
    padding: 8px;
    text-align: left;
  }

  th {
    background-color: var(--secondary-color);
  }

  .charts-container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-bottom: 30px;
  }

  .chart-container {
    flex: 1;
    min-width: 300px;
    height: 400px;
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    transition: height 0.3s ease;
  }

  .negative {
    color: var(--negative-color);
  }

  .totals-header {
    font-weight: bold;
    margin: 15px 0 5px;
    color: var(--totals-color);
  }

  .table-header {
    font-weight: bold;
    margin: 15px 0 5px;
    color: var(--table-header-color);
    font-size: 1.2em;
  }

  .table-responsive {
    overflow-x: auto;
    margin-bottom: 15px;
  }

  /* =================== Payslip Modal =================== */

  #payslipOverlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 70vh;
    background: var(--modal-bg);
    z-index: 999;
  }

  #payslipModal {
    position: fixed;
    top: 0;
    right: -100%;
    width: 50%;
    max-width: 600px;
    height: 100%;
    max-height:calc(80vh);
    background: #fff;
    z-index: 1000;
    box-shadow: -2px 0 10px rgba(0,0,0,0.3);
    overflow-y: auto;
    padding: 20px;
    margin-bottom: 50px;
    transition: right 0.3s ease-in-out;
    border-left: 4px solid var(--primary-color);
    border-radius: 4px 0 0 4px;
  }

  #payslipModal.show {
    right: 0;
  }

  #payslipModal h3 {
    color: var(--primary-color);
    margin-bottom: 10px;
  }

  #closePayslipBtn {
    float: right;
    font-size: 1.5em;
    background: none;
    border: none;
    cursor: pointer;
    color: var(--negative-color);
  }

  #payslipModal label {
    font-weight: bold;
  }

  #payslipModal input,
  #payslipModal select {
    padding: 6px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 13px;
    width: 100%;
  }

  #payslipModal table {
    width: 100%;
    border-collapse: collapse;
    overflow: visible;
    font-size: 12px;
    margin-top: 15px;
    margin-bottom:20px;
    padding-bottom: 1em;
  }

  #payslipModal th,
  #payslipModal td {
    border: 1px solid var(--border-color);
    padding: 6px;
  }

  #payslipModal th {
    background-color: var(--secondary-color);
    color: var(--primary-color);
  }

  #payslipSummary {
    font-weight: bold;
    margin-top: 10px;
    color: var(--totals-color);
    font-size: 14px;
  }

  /* =================== Payslip Button =================== */
  #togglePayslipBtn {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 8px 14px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
  }

  #togglePayslipBtn:hover {
    background-color: #1d3fa2;
  }
 #saveAsImageBtn {
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 0.5em 1em;
      margin-top: 1em;
      cursor: pointer;
    }
    #saveAsImageBtn:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
  
  .filter-container {
      font-size: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    /* Ensure no parent clipping */
    body, html {
      overflow: visible !important;
    }
  
  .disclaimer {
    font-size: 12px;
    color: #555;
    padding: 1em 0; /* Padding above and below */
    text-align: center;
  }
  
  /* =================== Responsive =================== */
  @media (max-width: 768px) {
    .filters {
      flex-direction: column;
      gap: 15px;
    }

    .charts-container {
      flex-direction: column;
    }

    .chart-container {
      height: auto;
      width: 100%;
      aspect-ratio: 1 / 1;
    }

    #payslipModal {
      width: 100%;
      max-width: none;
    }

    #payslipModal table {
      font-size: 11px;
    }
  }
</style>

  
</head>
<body>
  <div class="dashboard-container">   
    <h1>
       REVENUE Dashboard 
    </h1>
    

      <div class="divider"></div>
    
    
    <div class="filters">
      <div class="filter-group">
        <label for="monthFilter">Time Period</label>
        <select id="monthFilter">
          <option value="ALL">ALL</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="searchInput">Search Clinics or Treatments</label>
        <input type="text" id="searchInput" placeholder="Search...">
      </div>

      <!-- Button to toggle the payslip modal -->
<button id="togglePayslipBtn">Show Payslip</button>

<!-- Payslip modal -->
<div id="payslipModal" style="display:none; position:fixed; top:10%; left:10%; width:80%; bottom:40%; background:white; border:1px solid #ccc; padding:1em; box-shadow:0 0 10px rgba(0,0,0,0.2); z-index:1000; overflow:auto;">
  <button id="closePayslipBtn" style="float:right; padding:0.5em;">âœ•</button>
  <h3>Kanu - Payslip & Clinic Logs</h3>
  <div style="font-size: 12px; display: flex; justify-content: center; flex-wrap: nowrap; gap: 1px;">
    <label>Select Clinic:
      <select id="payslipCategory" style="width: 150px;"></select>
    </label>
    <label>Period From:
      <input type="date" id="payslipFromDate" style="width: auto;">
    </label>
    <label>Period To:
      <input type="date" id="payslipToDate" style="width: auto;">
    </label>
    <button id="saveAsImageBtn" style="margin-top:1em; ">Save</button>
  </div>
  <p id="payslipSummary" style="display: flex; justify-content: space-around; align-tems: flex-start; gap: 2em; font-weight:bold; font-size:12px; margin-top:1em;"></p>
  <table style="width:100%; font-size:12px; border-collapse: collapse; margin-top:10px;">
    <thead>
      <tr>
        <th>Date</th><th>Day</th><th>Branch</th><th>Count</th><th>Rate</th><th>Total</th>
      </tr>
    </thead>
    <tbody id="payslipTableBody"></tbody>
  </table>
</div>

      
      <div class="filter-group">
        <label>Filter by Clinic</label>
        <div id="categoryFilters" class="radio-group">
          <label><input type="radio" name="category" value="ALL" checked> ALL</label>
        </div>
      </div>
    </div>

    <div class="totals" id="totalsDisplay"></div>

    <div class="divider"></div>
  
    
    <div id="chart1" class="charts-container">
      <div class="chart-container">
        <canvas id="patientCountChart"></canvas>
      </div>
      <div id="chart2" class="chart-container">
        <canvas id="earningsChart"></canvas>
      </div>
   
<div id="chart3" class="chart-container">
    <canvas id="workloadByDayChart"></canvas>
</div>

<div id="chart4" class="chart-container">
    <canvas id="earningsByDayChart"></canvas>
</div>
    </div>
    
    <div class="divider"></div>

    
    <div class="table-header">Logbook</div>
    
    <table id="dataTable">
      <thead>
        <tr>
          <th>Date</th>
          <th>Clinic</th>
          <th>Branch</th>
          <th>Count</th>
          <th>Rate</th>
          <th>Earned</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- Include html2canvas library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  
  <script>
    // Configuration
    const CONFIG = {
      csvUrl: "https://docs.google.com/spreadsheets/d/e/2PACX-1vSmajYkga40XsAJNrKvXEFRh8TNCG_-ojL67wytOlvLJqZJdYrquS4IxikIQi84T95ftbq48sell78r/pub?gid=1192759857&single=true&output=csv",
      categoryColors: {
        'The Clinic': "#ff8c00",
        'Aqua Physio': "#3357FF"
      },
      
      labelSettings: {
        font: {
          family: 'Arial Narrow',
          size: 9
        },
        color: '#444444' // dark grey
      }
    };

    // State
    const STATE = {
      rawData: [],
      filteredData: [],
      charts: {
        patientCount: null,
        earnings: null
      }
    };

    // DOM Elements
    const DOM = {
      monthFilter: document.getElementById('monthFilter'),
      searchInput: document.getElementById('searchInput'),
      categoryFilters: document.getElementById('categoryFilters'),
      dataTableBody: document.querySelector('#dataTable tbody'),
      totalsDisplay: document.getElementById('totalsDisplay'),
      patientCountChart: document.getElementById('patientCountChart'),
      earningsChart: document.getElementById('earningsChart'),
      workloadByDayChart: document.getElementById('workloadByDayChart'),
      earningsByDayChart: document.getElementById('earningsByDayChart')

    };

    // Initialize
    document.addEventListener('DOMContentLoaded', initialize);

    async function initialize() {
      await fetchData();
      setupEventListeners();
      populateFilters();
      adjustChartContainerHeights();
      applyFilters();
      renderCharts();
    }

    function setupEventListeners() {
      DOM.monthFilter.addEventListener('change', debounce(applyFilters, 250));
      DOM.searchInput.addEventListener('input', debounce(applyFilters, 250));
      DOM.categoryFilters.addEventListener('change', applyFilters);
    }

    // Toggle modal
document.getElementById('togglePayslipBtn').addEventListener('click', () => {
  document.getElementById('payslipModal').style.display = 'block';
  document.getElementById('payslipModal').classList.add('show');
  populatePayslipCategories();
  renderPayslipTable(); // initial
});
document.getElementById('closePayslipBtn').addEventListener('click', () => {
  document.getElementById('payslipModal').style.display = 'none';
  document.getElementById('payslipModal').classList.remove('show');
});
['payslipCategory', 'payslipFromDate', 'payslipToDate'].forEach(id => {
  document.getElementById(id).addEventListener('change', renderPayslipTable);
});

// Fill dropdown
function populatePayslipCategories() {
  const select = document.getElementById('payslipCategory');
  const unique = [...new Set(STATE.rawData.map(r => r['Category']).filter(Boolean))];
  select.innerHTML = `<option value="ALL">ALL</option>` + unique.map(c => `<option>${c}</option>`).join('');
}

   
// Render payslip
function renderPayslipTable() {
  const category = document.getElementById('payslipCategory').value;
  const fromStr = document.getElementById('payslipFromDate').value;
  const toStr = document.getElementById('payslipToDate').value;
  const from = fromStr ? new Date(fromStr) : null;
  const to = toStr ? new Date(toStr) : null;

  const tableBody = document.getElementById('payslipTableBody');
  tableBody.innerHTML = '';
  let total = 0;

  const data = STATE.rawData.filter(row => {
    if (!row['Receipt Date']) return false;
    const date = new Date(row['Receipt Date']);
    if (isNaN(date)) return false;
    const inCat = category === 'ALL' || row['Category'] === category;
    const inRange = (!from || date >= from) && (!to || date <= to);
    return inCat && inRange;
  });

  if (data.length === 0) {
    tableBody.innerHTML = `<tr><td colspan="6" style="text-align:center; font-size:12px;">No records found</td></tr>`;
    document.getElementById('payslipSummary').textContent = '';
    return;
  }

  data.forEach(row => {
    const isAquaHrly = row['Item Name'] === 'Aqua Hrly';

    const qty = parseFloat(row['Quantity']) || 0;
    const qtyFormatted = isAquaHrly ? qty.toFixed(2) : parseInt(qty);

    const rate = parseFloat(row['price']) || 0;
    const amount = parseFloat(row['Per patient total']) || (qty * rate);
    total += amount;

    const dateObj = new Date(row['Receipt Date']);
    const day = dateObj.toLocaleDateString('en-GB', { weekday: 'short' });
    const dateStr = dateObj.toLocaleDateString('en-GB');

    const amountClass = amount < 0 ? ' class="negative"' : '';

    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${dateStr}</td>
      <td>${day}</td>
      <td>${row['Item Name']}</td>
      <td>${qtyFormatted}</td>
      <td>S$${Math.round(rate)}</td>
      <td${amountClass}>S$${Math.round(amount)}</td>
    `;
    tableBody.appendChild(tr);
  });

 const totalClass = total < 0 ? ' class="negative"' : '';
const totalRounded = Math.round(total);

// Calculations
const kanuCPF = totalRounded * 0.20;
const clinicCPF = totalRounded * 0.17;
const sinda = 7;
const totalCPF = kanuCPF + clinicCPF;
const kanuBank = totalRounded - kanuCPF;

// Format function
const fmt = val => `S$ ${Math.round(val).toLocaleString('en-SG')}`;

// Column contents
const earningsHTML = `
  <div>
    <strong>Earnings</strong><br>
    Gross Pay: <span${totalClass}>${fmt(totalRounded)} est</span><br>
    Nett Pay: ${fmt(kanuBank)} est
  </div>
`;

const cpfHTML = `
  <div>
    <strong>CPF Deductions</strong><br>
    Kanu CPF: ${fmt(kanuCPF)} est<br>
    Clinic CPF: ${fmt(clinicCPF)} est<br>
  </div>
`;
  
const cpfHTML2 = `
  <div>
    <strong>Other & CPF Total</strong><br>
    SINDA: ${fmt(sinda)} est<br>
    Total CPF: ${fmt(totalCPF)} est
  </div>
`;

// Display
document.getElementById('payslipSummary').innerHTML = earningsHTML + cpfHTML + cpfHTML2;

  
 // Enable Save button if table has data
      document.getElementById('saveAsImageBtn').disabled = false;
    }

    // Fetch and parse CSV
    async function fetchAndParseCSV() {
      try {
        const response = await fetch(CONFIG.csvUrl);
        if (!response.ok) throw new Error('Failed to fetch CSV');
        const csvText = await response.text();

        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            STATE.rawData = results.data;
            populatePayslipCategories();
            renderPayslipTable();
          },
          error: function(err) {
            console.error('Error parsing CSV:', err);
            alert('Failed to load table data.');
          }
        });
      } catch (err) {
        console.error('Error loading CSV:', err);
        alert('Failed to load table data.');
      }
    }

    // Call fetchAndParseCSV on page load
    fetchAndParseCSV();

    // Save as Image button logic (capture entire modal without save button)
    document.getElementById('saveAsImageBtn').addEventListener('click', function() {
      const modal = document.getElementById('payslipModal');

      if (!modal) {
        console.error('Modal element not found');
        alert('Error: Modal not found. Please ensure the modal is loaded.');
        return;
      }

      // Create a temporary clone
      const clone = modal.cloneNode(true);
      clone.className = modal.className;
      clone.id = 'payslipModal';
      clone.style.position = 'absolute';
      clone.style.left = '-9999px';
      clone.style.display = 'block';
      clone.style.width = modal.offsetWidth + 'px';
      clone.style.height = 'auto';
      clone.style.maxHeight = 'none';
      clone.style.overflow = 'visible';
      clone.style.paddingBottom = "20px";
      

      // Remove save button from clone
      const saveBtn = clone.querySelector('#saveAsImageBtn');
      if (saveBtn) {
        saveBtn.parentNode.removeChild(saveBtn);
      }
      
      // Remove cross button from clone
      const closeBtn = clone.querySelector('#closePayslipBtn');
      if (closeBtn) {
        closeBtn.parentNode.removeChild(closeBtn);
      }
      
      // Remove table container max-height for clone to show all rows
      const clonedTableContainer = clone.querySelector('.table-container');
      if (clonedTableContainer) {
        clonedTableContainer.style.maxHeight = 'none';
        clonedTableContainer.style.overflow = 'visible';
        clonedTableContainer.style.paddingBottom = '20px'; // Forced padding for image
      }
      
      // Add disclaimer below table
      const disclaimer = document.createElement('p');
      disclaimer.className = 'disclaimer';
      disclaimer.textContent = 'Disclaimer: Generated for time log comparison purposes only. Rate & Total E&OE.';
      if (clonedTableContainer && clonedTableContainer.parentNode) {
        clonedTableContainer.parentNode.appendChild(disclaimer); // Append to ensure placement
      } else {
        console.warn('Could not append disclaimer; appending to clone root');
        clone.appendChild(disclaimer);
      }

      // Sync category dropdown
      const originalSelect = document.getElementById('payslipCategory');
      const selectedValue = originalSelect ? originalSelect.value : 'ALL';
      const clonedSelect = clone.querySelector('#payslipCategory');
      if (clonedSelect) {
        Array.from(clonedSelect.options).forEach(option => {
          option.selected = option.value === selectedValue;
        });
        clonedSelect.value = selectedValue;
      }

      // Apply styles to clone
      clone.style.fontFamily = 'Arial, sans-serif';
      clone.style.padding = '1em';
      clone.style.background = 'white';
      clone.style.border = '1px solid #ccc';
      clone.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)';
      const clonedH3 = clone.querySelector('h3');
      if (clonedH3) {
        clonedH3.style.fontSize = '18px';
        clonedH3.style.fontWeight = 'bold';
        clonedH3.style.margin = '0 0 10px 0';
        clonedH3.style.color = '#000';
      }
      const clonedFilterContainer = clone.querySelector('.filter-container');
      if (clonedFilterContainer) {
        clonedFilterContainer.style.fontSize = '12px';
        clonedFilterContainer.style.display = 'flex';
        clonedFilterContainer.style.flexWrap = 'wrap';
        clonedFilterContainer.style.gap = '10px';
      }
      const clonedSummary = clone.querySelector('#payslipSummary');
      if (clonedSummary) {
        clonedSummary.style.fontWeight = 'bold';
        clonedSummary.style.fontSize = '12px';
        clonedSummary.style.marginTop = '1em';
        clonedSummary.style.color = '#000';
      }

      document.body.appendChild(clone);

      // Force reflow
      clone.offsetHeight;

      // Log dimensions and select state for debugging
      console.log('Original modal size:', modal.scrollWidth, modal.scrollHeight);
      console.log('Clone size:', clone.scrollWidth, clone.scrollHeight);
      console.log('Selected category:', selectedValue);
      console.log('Cloned select value:', clonedSelect ? clonedSelect.value : 'N/A');

      setTimeout(() => {
        html2canvas(clone, {
          scale: 2,
          backgroundColor: '#ffffff',
          useCORS: true,
          logging: true,
          scrollX: 0,
          scrollY: 0,
          width: clone.scrollWidth,
          height: clone.scrollHeight
        }).then(canvas => {
          // Remove clone
          document.body.removeChild(clone);
          console.log('Canvas size:', canvas.width, canvas.height);

          // Trigger download
          const image = canvas.toDataURL('image/png');
          const link = document.createElement('a');
          link.href = image;
          link.download = 'KanuTimeLog.png';
          link.click();
        }).catch(err => {
          // Remove clone on error
          document.body.removeChild(clone);
          console.error('Error generating image:', err);
          alert('Failed to save the modal as an image. Please try again.');
        });
      }, 300);
    });
    
// end payslip
    
    
    async function fetchData() {
      try {
        const response = await fetch(CONFIG.csvUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.text();
        parseCSV(data);
      } catch (error) {
        console.error('Error fetching data:', error);
        alert('Failed to load data. Please check your connection and try again.');
      }
    }

    function parseCSV(data) {
      const lines = data.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.trim());

      STATE.rawData = lines.slice(1).map(line => {
        const values = line.split(',');
        const entry = {};
        headers.forEach((header, index) => {
          entry[header] = values[index] ? values[index].trim() : '';
        });
        return entry;
      });
    }

    function populateFilters() {
      // Extract unique values for filters
      const months = new Set();
      const categories = new Set();

      STATE.rawData.forEach(row => {
        months.add(row['Month Year'] || row['Month-Year']);
        categories.add(row['Category']);
      });

      // Sort months chronologically
      const sortedMonths = Array.from(months).sort();
      
      // Populate month filter
      sortedMonths.forEach(month => {
        const option = document.createElement('option');
        option.value = month;
        option.textContent = month;
        DOM.monthFilter.appendChild(option);
      });

      // Populate category filters
      Array.from(categories).sort().forEach(category => {
        const label = document.createElement('label');
        label.innerHTML = `<input type="radio" name="category" value="${category}"> ${category}`;
        DOM.categoryFilters.appendChild(label);
      });
    }

    function applyFilters() {
      const monthValue = DOM.monthFilter.value;
      const searchValue = DOM.searchInput.value.toLowerCase();
      const categoryRadios = document.getElementsByName('category');
      let selectedCategory = 'ALL';
      
      categoryRadios.forEach(radio => {
        if (radio.checked) selectedCategory = radio.value;
      });

      STATE.filteredData = STATE.rawData.filter(row => {
        const monthKey = row['Month Year'] ? 'Month Year' : 'Month-Year';
        const matchesMonth = monthValue === 'ALL' || row[monthKey] === monthValue;
        const itemName = (row['Item Name'] || '').toLowerCase();
        const category = (row['Category'] || '').toLowerCase();
        const matchesSearch = 
                  searchValue === '' || 
                  itemName.includes(searchValue) || 
                  category.includes(searchValue) ||
                  (searchValue.includes('camden') && category === 'aqua physio');
        const matchesCategory = selectedCategory === 'ALL' || row['Category'] === selectedCategory;
        
        return matchesMonth && matchesSearch && matchesCategory;
      });

      updateTable();
      updateTotals();
      updateCharts();
    }

    
     function updateTable() {
      // Clear table
      DOM.dataTableBody.innerHTML = '';
      
      if (STATE.filteredData.length === 0) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="6" style="text-align: center">No data matches your filters</td>`;
        DOM.dataTableBody.appendChild(tr);
        return;
      }
      
      // Create document fragment for better performance
      const fragment = document.createDocumentFragment();
      
      // Add rows
      STATE.filteredData.forEach(row => {
        const perPatientTotal = parseFloat(row['Per patient total']) || 0;
        const categoryColor = CONFIG.categoryColors[row['Category']] || '';
        
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${row['Date Convert']}</td>
          <td style="color: white; background-color: ${categoryColor}">${row['Category']}</td>
          <td>${row['Item Name']}</td>
          <td>${row['Quantity']}</td>
          <td>${formatCurrency(row['price'])}</td>
          <td class="${perPatientTotal < 0 ? 'negative' : ''}">${formatCurrency(perPatientTotal)}</td>
        `;
        fragment.appendChild(tr);
      });
      
      DOM.dataTableBody.appendChild(fragment);
    }


function updateTotals() {
  const formatCurrency = val =>
    '$' + (val || 0).toLocaleString('en-US', {
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    });

  const formatTimeFilterLabel = val => {
    if (val === "ALL") return "ALL TIME";
    const date = new Date(val);
    const month = date.toLocaleString('en-US', { month: 'short' }).toUpperCase();
    const year = date.getFullYear();
    return `${month} ${year}`;
  };

  const itemColors = {
    "Aperia": "#15b361",
    "Aqua": "#4994f5",
    "Campus": "#ccae54",
    "Marina": "#eb4034"
  };

  const groupTotals = {};
  const itemTotals = {};
  let grossTotal = 0;
  let aquaTotal = 0;
  
  // console.log("Filtered Data:", STATE.filteredData); //

  STATE.filteredData.forEach(row => {
    const val = parseFloat(row["Per patient total"]) || 0;
    const item = row["Item Name"];
    const firstWord = item.split(" ")[0];

    groupTotals[firstWord] = (groupTotals[firstWord] || 0) + val;
    itemTotals[item] = (itemTotals[item] || 0) + val;
    grossTotal += val;
  });

  const sortedGroups = Object.keys(groupTotals).sort();
  const displayedGroups = sortedGroups.filter(g => {
    if (g.startsWith("Aqua")) {
      aquaTotal += groupTotals[g];
      return false; // exclude Aqua groups from "The Clinic"
    }
    return groupTotals[g] > 0;
  });

  const showAqua = aquaTotal > 0;
  const monthLabel = formatTimeFilterLabel(DOM.monthFilter.value);

  const baseStyle = "text-align: center; vertical-align: middle; padding: 2px;";
  const blackBorder = "border: 1px solid black;";
  const borderLeft = "border-left: 1px solid black;";
  const borderTop = "border-top: 1px solid black;";
  const borderRight = "border-right: 1px solid black;";

  if (grossTotal === 0) {
    DOM.totalsDisplay.innerHTML = "<div style='text-align:center; padding:1em;'>No data for selected filter.</div>";
    return;
  }

  const tableHTML = `
    <div class="totals-header" style="text-align: left;">Earning Summary</div>
    <div class="table-responsive">
      <table style="width: 100%; border-collapse: collapse;">
        <tr>
          <td style="border: none;"></td>
          ${displayedGroups.length > 0 ? `<td colspan="${displayedGroups.length}" style="${blackBorder + baseStyle} background: #ff8c00; color: white; font-weight: bold;">The Clinic</td>` : ''}
          ${showAqua ? `<td style="${blackBorder + baseStyle} background: #3357FF; color: white; font-weight: bold;">Aqua Physio</td>` : ''}
        </tr>
        <tr>
          <td style="font-weight: bold; background: #ffffa3; ${blackBorder + baseStyle} color: green;">${monthLabel}</td>
          ${displayedGroups.map(clinic => `
            <td style="${blackBorder + baseStyle} background: ${itemColors[clinic] || '#ccc'}; color: yellow;">${clinic}</td>
          `).join('')}
          ${showAqua ? `<td style="${blackBorder + baseStyle} background: ${itemColors["Aqua"]}; color: yellow;">Camden</td>` : ''}
        </tr>
        <tr>
          <td style="border-left: none; border-bottom: none; ${borderRight + baseStyle}"></td>
          ${displayedGroups.map(clinic => {
            const total = groupTotals[clinic] || 0;
            return `<td style="${blackBorder + baseStyle}">${formatCurrency(total)}</td>`;
          }).join('')}
          ${showAqua ? `<td style="${blackBorder + baseStyle}">${formatCurrency(aquaTotal)}</td>` : ''}
        </tr>
        <tr>
          <td style="${blackBorder + baseStyle} font-weight: bold; background: #ffffa3;">Gross Total : 
            <span style="color: red; font-weight: bold;">${formatCurrency(grossTotal)}</span>
          </td>
          ${displayedGroups.length > 0 ? `<td colspan="${displayedGroups.length}" style="${blackBorder + baseStyle} background: #ff8c00; color: white; font-weight: bold;">${formatCurrency(grossTotal - aquaTotal)}</td>` : ''}
          ${showAqua ? `<td style="${blackBorder + baseStyle} background: #3357FF; color: white; font-weight: bold;">${formatCurrency(aquaTotal)}</td>` : ''}
        </tr>
      </table>
    </div>
  `;

  DOM.totalsDisplay.innerHTML = tableHTML;
}


    function formatTimeFilterLabel(value) {
  if (value === 'ALL') return 'ALL TIME';
  const [year, month] = value.split('-');
  const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                      'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
  const monthIndex = parseInt(month, 10) - 1;
  return `${monthNames[monthIndex]} ${year}`;
}    
    
    function formatCurrency(value) {
      const number = parseFloat(value);
      return isNaN(number) ? 'S$ 0.00' : `S$ ${number.toLocaleString('en-SG', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
    }

    function renderCharts() {
      const monthlyData = processDataForCharts();
      const dayData = prepareDayOfWeekData();
      renderPatientCountChart(monthlyData);
      renderEarningsChart(monthlyData);
      renderWorkloadByDayChart(dayData);
      renderEarningsByDayChart(dayData);
    }
    
  function updateCharts() {
  adjustChartContainerHeights();

  if (STATE.charts.patientCount) {
    STATE.charts.patientCount.destroy();
  }

  if (STATE.charts.earnings) {
    STATE.charts.earnings.destroy();
  }

  if (STATE.charts.workloadByDay) {
    STATE.charts.workloadByDay.destroy();
  }

  if (STATE.charts.earningsByDay) {
    STATE.charts.earningsByDay.destroy();
  }

  renderCharts();
}

    
    
    
    function adjustChartContainerHeights() {
  const chartContainers = document.querySelectorAll('.chart-container');
  const isMobile = window.innerWidth <= 768;
  
  chartContainers.forEach(container => {
    // On mobile, set a smaller fixed height
    if (isMobile) {
      container.style.height = 'auto';
    } else {
      container.style.height = '400px';
    }
  });
}

// Add window resize event listener

    const chartContainers = [
  document.getElementById('chart1'),
  document.getElementById('chart2'),
  document.getElementById('chart3'),
  document.getElementById('chart4'),
];

const previousSizes = new Map();
    
window.addEventListener('resize', debounce(() => {
 ChartContainers.forEach((container, index) => {
    const width = container.offsetWidth;
    const height = container.offsetHeight;
    const key = `chart${index + 1}`;
    const prev = previousSizes.get(key) || {};

    if (width !== prev.width || height !== prev.height) {
      previousSizes.set(key, { width, height });

  adjustChartContainerHeights();
  updateCharts();
}
 });
}, 250));

    
    function processDataForCharts() {
      const monthlyItemCount = {};
      const monthlyCategoryEarnings = {};
      const allMonths = new Set();
      const itemSet = new Set();
      const categorySet = new Set();
       
      STATE.rawData.forEach(row => {
        const month = row['Month Year'] || row['Month-Year'];
        const item = row['Item Name'];
        const category = row['Category'];
        const value = parseFloat(row['Per patient total']) || 0;
        const quantity = parseInt(row['Quantity'], 10) || 1;

        allMonths.add(month);
        itemSet.add(item);
        categorySet.add(category);

        // Initialize if needed
        if (!monthlyItemCount[month]) monthlyItemCount[month] = {};
        if (!monthlyItemCount[month][item]) monthlyItemCount[month][item] = 0;
        
        if (!monthlyCategoryEarnings[month]) monthlyCategoryEarnings[month] = {};
        if (!monthlyCategoryEarnings[month][category]) monthlyCategoryEarnings[month][category] = 0;
        
        // Add values
        monthlyItemCount[month][item] += quantity;
        monthlyCategoryEarnings[month][category] += value;
      });

      return {
        months: Array.from(allMonths).sort(),
        items: Array.from(itemSet).sort(),
        categories: Array.from(categorySet).sort(),
        itemCounts: monthlyItemCount,
        categoryEarnings: monthlyCategoryEarnings
      };
    }

    // Helper to convert JS Date to 'M', 'T', etc.
function getDayLabel(dateString) {
  const dayMap = ['S', 'M', 'T', 'W', 'Th', 'F', 'S'];
  const date = new Date(dateString);
  const day = date.getDay();
  return dayMap[day];
}

function prepareDayOfWeekData() {
  const days = ['M', 'T', 'W', 'Th', 'F'];
  const workloadByDay = {};
  const earningsByDay = {};
  const itemsSet = new Set();
  const clinicsSet = new Set();
  
  STATE.filteredData.forEach(row => {
    // Parse date string to get day of week
    const dateStr = row['Date Convert'];
    if (!dateStr) return;
    
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) return; // Skip invalid dates
    
    const dayNum = date.getDay();
    if (dayNum === 0 || dayNum === 6) return; // Skip weekends (0=Sunday, 6=Saturday)
    
    const dayLabel = days[dayNum - 1]; // Adjust index (Monday is index 0 in our days array)
    const item = row['Item Name'];
    const clinic = row['Category']; // Keep the clinic category for earnings chart
    const quantity = parseInt(row['Quantity'], 10) || 0;
    const value = parseFloat(row['Per patient total']) || 0;
    
    itemsSet.add(item);
    clinicsSet.add(clinic);
    
    // For workload - track by item (detailed view)
    if (!workloadByDay[dayLabel]) workloadByDay[dayLabel] = {};
    if (!workloadByDay[dayLabel][item]) workloadByDay[dayLabel][item] = 0;
    workloadByDay[dayLabel][item] += quantity;
    
    // For earnings - track by clinic (summary view)
    if (!earningsByDay[dayLabel]) earningsByDay[dayLabel] = {};
    if (!earningsByDay[dayLabel][clinic]) earningsByDay[dayLabel][clinic] = 0;
    earningsByDay[dayLabel][clinic] += value;
  });
  
  return { 
    days, 
    workloadByDay, 
    earningsByDay,
    items: Array.from(itemsSet),
    clinics: Array.from(clinicsSet)
  };
}
    
 // Global color cache
const colorCache = {
  items: {},       // Cache for items (fixed colors or fallback)
  categories: {},  // Cache for categories (fixed colors or fallback)
  clinics: {}      // Cache for clinics (fixed colors or fallback)
};

// Define the color limits for fallback (if fixed not defined)
const colorLimits = {
  items: 10,
  categories: 4,
  clinics: 4
};

// Predefined fallback colors (used only if fixed color not found)
const predefinedColors = [
  "#4d99ff", "#4d6cff", "#ff981b", "#ff8c01", "#ffa334", "#e67e00", "#e77e00", "#FF33FF", "#F6FF33", "#33FF9A",
  "#3357FF", "#ff8c00", "#FF5733", "#33B5FF"
];

// Fixed color mapping for consistent visual identity
const fixedColors = {
  items: {
    "Aperia - New": "#15b361",         // dark orange
    "Aperia - Repeat": "#15b361",      // light orange
    "Aqua Comm - New": "#00d0ff",      // dark blue
    "Aqua Comm - Repeat": "#00d0ff",   // light blue
    "Aqua Hrly": "#4994f5",            // Aqua-specific
    "Campus - New": "#ccae54",
    "Campus - Repeat": "#ccae54",
    "Campus Student - New": "#a900b5",
    "Campus Student - Repeat": "#a900b5",
    "Marina - New": "#eb4034",
    "Marina - Repeat": "#eb4034"
  },
  categories: {
    "Aqua Physio": "#3357FF",
    "The Clinic": "#ff8c00"
  },
  clinics: {
    "Aperia": "#15b361",
    "Aqua": "#4994f5",
    "Campus": "#ccae54",
    "Marina": "#eb4034"
  }
};

// Function to get or assign a color to a category (items, categories, clinics)
function getCategoryColor(category, type) {
  const categoryCache = colorCache[type];
  const fixedColorMap = fixedColors[type];

  // Return cached color if already assigned
  if (categoryCache[category]) {
    return categoryCache[category];
  }

  // Use fixed color if defined
  if (fixedColorMap && fixedColorMap[category]) {
    categoryCache[category] = fixedColorMap[category];
    return fixedColorMap[category];
  }

  // Fallback to predefined color if needed
  let colorIndex;
  if (type === 'items') {
    colorIndex = Object.keys(categoryCache).length % colorLimits.items;
  } else if (type === 'categories' || type === 'clinics') {
    colorIndex = (Object.keys(categoryCache).length % colorLimits.categories) + colorLimits.items;
  }

  const color = predefinedColors[colorIndex];
  categoryCache[category] = color;
  return color;
}

    
    
    function renderPatientCountChart(data) {
      const patientCountData = {
        labels: data.months,
        datasets: data.items.map((item, i) => ({
          label: item,
          data: data.months.map(month => (data.itemCounts[month] && data.itemCounts[month][item]) || 0),
          backgroundColor: getCategoryColor(item, 'items'),
          categoryPercentage: 0.8,
          barPercentage: 0.9
        }))
      };

   
  const totalFormattedLabels = data.months.map(month => {
    let patientCount = 0;
    let hours = 0;

    for (const item of data.items) {
      const value = (data.itemCounts[month] && data.itemCounts[month][item]) || 0;
      if (/^aqua/i.test(item)) {
        hours += value;
      } else {
        patientCount += value;
      }
    }

    let label = '';
    if (patientCount > 0) label += `${patientCount}pt`;
    if (hours > 0) label += `${patientCount > 0 ? ', ' : ''}${hours}h`;
    return label;
  });
      
      
      STATE.charts.patientCount = new Chart(DOM.patientCountChart, {
        type: 'bar',
        data: patientCountData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                font: { size: 10 },
                boxWidth: 10,
                boxHeight: 10
              }
            },
            title: { 
              display: true, 
              text: 'Workload by Clinic      |     ALL TIME', 
              color: '#2a52be', 
              font: { size: 14 } 
            },
            datalabels: {
              display: function(context) {
                return context.dataset.data[context.dataIndex] > 4;
              },
              anchor: 'center',
              align: 'center',
              offset: 0 ,
              color: '#fff', //CONFIG.labelSettings.color,
              font: { size: 10 }, //CONFIG.labelSettings.font,
              formatter: function(value) {
                return value;
              }
            }
          },
          scales: {
            x: { stacked: true,
               font: {
      size: 8  // ðŸ‘ˆ Change this value to your preferred font size
    },
                ticks: {
      callback: function(value, index) {
        const rawLabel = this.chart.data.labels[index];
        if (!rawLabel || !rawLabel.includes('-')) return rawLabel;

        const [year, month] = rawLabel.split('-');
        const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
                            'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const monthAbbr = monthNames[parseInt(month, 10) - 1] || '';
        const yearShort = year.slice(2);
        return `${monthAbbr}'${yearShort}`;
      }
    }
               
               },
            y: { 
              stacked: true,
              beginAtZero: true,
              grace: '10%', // Add space at the top for labels
              ticks: {
            callback: function(value) {
              return value.toLocaleString(); // Optionally add "Patients: " + value
                }
              }
            }
          }
        },
        plugins: [
      ChartDataLabels,
      {
        id: 'totalWorkloadPlugin',
        afterDatasetsDraw(chart) {
          const { ctx, data, scales: { x, y } } = chart;

          data.labels.forEach((label, index) => {
            const totalLabel = totalFormattedLabels[index];

            // Calculate total value to position label correctly
            const totalValue = chart.data.datasets.reduce((sum, ds) => {
              return sum + ds.data[index];
            }, 0);

            const xCenter = x.getPixelForValue(index);
            const yTop = y.getPixelForValue(totalValue);

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.fillStyle = '#ff0000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(totalLabel, xCenter, yTop - 4);
            ctx.restore();
          });
        }
      }
    ]
      });
    }

    function renderEarningsChart(data) {
      const earningsData = {
        labels: data.months,
        datasets: data.categories.map((cat, i) => ({
          label: cat,
          data: data.months.map(month => (data.categoryEarnings[month] && data.categoryEarnings[month][cat]) || 0),
          backgroundColor: getCategoryColor(cat, 'categories'),
          categoryPercentage: 0.8,
          barPercentage: 0.9
        }))
      };
      
      const totalValues = data.months.map(month => {
  return data.categories.reduce((sum, cat) => {
    return sum + ((data.categoryEarnings[month] && data.categoryEarnings[month][cat]) || 0);
  }, 0);
});

    
      STATE.charts.earnings = new Chart(DOM.earningsChart, {
        type: 'bar',
        data: earningsData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                font: 
                   { size: 11 
                   },
                boxWidth: 10,
                boxHeight: 10,
                padding: 10
                       },  
            },
            title: { 
              display: true, 
              text: 'Monthly Revenue      |     ALL TIME', 
              color: '#2a52be', 
              font: { size: 14 },
              padding: 
                  {
                top: 13,
               bottom: 27
                  }
            },
            datalabels: {
              display: function(context) {
                return context.dataset.data[context.dataIndex] > 0;
              },
              anchor: 'center',
              align: 'center',
              rotation: 0,
              color: '#fff',
              font: { size: 10 },
              formatter: function(value) {
                return value.toLocaleString('en-SG', {
                  minimumFractionDigits: 0,
                  maximumFractionDigits: 0
                });
              }
            }
          },
          scales: {
            x: { stacked: true,
               font: {
      size: 8  // ðŸ‘ˆ Change this value to your preferred font size
    },
                ticks: {
      callback: function(value, index) {
        const rawLabel = this.chart.data.labels[index];
        if (!rawLabel || !rawLabel.includes('-')) return rawLabel;

        const [year, month] = rawLabel.split('-');
        const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
                            'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const monthAbbr = monthNames[parseInt(month, 10) - 1] || '';
        const yearShort = year.slice(2);
        return `${monthAbbr}'${yearShort}`;
      }
    }
               
               },
            y: {
              stacked: true,
              beginAtZero: true,
               grace: '10%',
              ticks: {
                callback: function(value) {
                  return 'S$ ' + value.toLocaleString('en-SG', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                  });
                },
                //stepSize: 500,
              }
            }
          }
        },
     plugins: [
      ChartDataLabels,
      {
        // Custom plugin to render total value on top
        id: 'totalValuePlugin',
        afterDatasetsDraw(chart) {
          const { ctx, data, scales: { x, y } } = chart;

          data.labels.forEach((label, index) => {
            const total = totalValues[index];
            const xCenter = x.getPixelForValue(index);
            const yTop = y.getPixelForValue(total);

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.fillStyle = '#ff0000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(
              'S$' + total.toLocaleString('en-SG', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
              } ),
              xCenter,
              yTop - 4
            );
            ctx.restore();
          });
        }
      }
    ]
      });
    }
    
    
function renderWorkloadByDayChart(data) {
  const workloadData = {
    labels: data.days,
    datasets: data.items.map((item, i) => ({
      label: item,
      data: data.days.map(day => {
        return (data.workloadByDay[day] && data.workloadByDay[day][item]) || 0;
      }),
      backgroundColor: getCategoryColor(item, 'items'),
      categoryPercentage: 0.8,
      barPercentage: 0.9
    }))
  };

  STATE.charts.workloadByDay = new Chart(DOM.workloadByDayChart, {
    type: 'bar',
    data: workloadData,
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false,
          position: 'top',
          labels: {
            font: { size: 11 },
            boxWidth: 10,
            boxHeight: 10
          }
        },
        title: {
          display: true,
          text: 'Workload by Days      |     '  + formatTimeFilterLabel(DOM.monthFilter.value),
          color: '#2a52be',
          font: { size: 14 },
          padding: {
            top: 10,
            bottom: 30
          }
        },
        datalabels: {
          display: function(context) {
            return context.dataset.data[context.dataIndex] > 2;
          },
          anchor: 'center',
          align: 'center',
          color: '#fff',
          font: { size: 10 },
          formatter: function(value) {
            return value;
          }
        }
      },
      scales: {
        x: {
          stacked: true,
          ticks: { font: { size: 10 } }
        },
        y: {
          stacked: true,
          grace: '10%',
          beginAtZero: true
  }
      }
    },
    plugins: [
      ChartDataLabels,
      {
        id: 'totalLabels',
        afterDatasetsDraw(chart) {
          const { ctx, data, scales: { x, y } } = chart;

          data.labels.forEach((label, index) => {
            let ptTotal = 0;
            let hTotal = 0;

            data.datasets.forEach(ds => {
              const val = ds.data[index] || 0;
              if (ds.label.toLowerCase().startsWith('aqua')) {
                hTotal += val;
              } else {
                ptTotal += val;
              }
            });

            const total = `${ptTotal}pt${hTotal > 0 ? `, ${hTotal}h` : ''}`;

            const xPos = x.getPixelForValue(index);
            const stackedTotal = ptTotal + hTotal;
            const yPos = y.getPixelForValue(stackedTotal);

            ctx.save();
          ctx.font = 'bold 11px sans-serif';
            ctx.fillStyle = '#ff0000';
            ctx.textAlign = 'center';
            ctx.fillText(total, xPos, yPos - 6);
            ctx.restore();
          });
        }
      }
    ]
  });
}



function renderEarningsByDayChart(data) {
  // Prepare data for the chart
  const earningsData = {
    labels: data.days,
    datasets: data.clinics.map(clinic => ({
      label: clinic,
      data: data.days.map(day => {
        return (data.earningsByDay[day] && data.earningsByDay[day][clinic]) || 0;
      }),
      backgroundColor: getCategoryColor(clinic, 'categories'),
      categoryPercentage: 0.8,
      barPercentage: 0.9
    }))
  };

  // Calculate total earnings per day
  const totalValues = data.days.map(day => {
    return data.clinics.reduce((sum, clinic) => {
      return sum + ((data.earningsByDay[day] && data.earningsByDay[day][clinic]) || 0);
    }, 0);
  });

  // Render the chart
  STATE.charts.earningsByDay = new Chart(DOM.earningsByDayChart, {
    type: 'bar',
    data: earningsData,
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false,
          position: 'top',
          labels: {
            font: { size: 11 },
            boxWidth: 10,
            boxHeight: 10
          }
        },
        title: {
          display: true,
          text: 'Revenue by Days      |     '  + formatTimeFilterLabel(DOM.monthFilter.value),
          color: '#2a52be',
          font: { size: 14 },
          padding: {
            top: 10,
            bottom: 30
          }
        },
        datalabels: {
          display: function (context) {
            return context.dataset.data[context.dataIndex] > 0;
          },
          anchor: 'center',
          align: 'center',
          rotation: 0,
          color: '#fff',
          font: { size: 10 },
          formatter: function (value) {
            return value.toLocaleString('en-SG', {
              minimumFractionDigits: 0,
              maximumFractionDigits: 0
            });
          }
        }
      },
      scales: {
        x: {
          stacked: true,
          ticks: {
            font: { size: 10 }
          }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: {
            callback: function (value) {
              return 'S$ ' + value.toLocaleString('en-SG', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
              });
            }
          }
        }
      }
    },
    plugins: [
      ChartDataLabels,
      {
        id: 'totalValuePlugin',
        afterDatasetsDraw(chart) {
          const { ctx, data, scales: { x, y } } = chart;
          data.labels.forEach((label, index) => {
            const total = totalValues[index];
            const xCenter = x.getPixelForValue(index);
            const yTop = y.getPixelForValue(total);

            ctx.save();
            ctx.font = 'bold 11px sans-serif';
            ctx.fillStyle = '#ff0000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(
              'S$' + total.toLocaleString('en-SG', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
              }),
              xCenter,
              yTop - 4
            );
            ctx.restore();
          });
        }
      }
    ]
  });
}

    
    
    // Utility Functions
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
  </script>
</body>
</html>
