<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kanu Earnings Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
  <style>
    :root {
      --primary-color: #2A52BE;
      --secondary-color: #d5e3e8;
      --clinic-color: #FFBF65;
      --aqua-color: #BDD7BF;
      --border-color: #ccc;
      --negative-color: red;
      --totals-color: blue;
      --table-header-color: green;
    }
    
    body { 
      font-family: 'Arial Narrow', sans-serif; 
      margin: 20px;
      line-height: 1.6;
    }
    
    h1 {
      color: var(--primary-color);
      font-size: 2em;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
      margin-bottom: off;
    }

    .dashboard-container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 30px;
      padding: 15px;
      background-color: #f5f5f5;
      border-radius: 5px;
    }
    
    .filter-group {
      display: flex;
      flex-direction: column;
      min-width: 200px;
    }
    
    label {
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    select, input {
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
    }
    
    .radio-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
        .divider {
  height: 2px;
  background-color: #ccc;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin: 40px 0;
}
  
    
    .totals {
      margin-bottom: 30px;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 30px;
    }
    
    th, td {
      border: 1px solid var(--border-color);
      padding: 8px;
      text-align: left;
    }
    
    th {
      background-color: var(--secondary-color);
    }
    
    .charts-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .chart-container {
      flex: 1;
      min-width: 300px;
      height: 400px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 5px;
    }
    
    .negative {
      color: var(--negative-color);
    }
    
    .totals-header {
      font-weight: bold;
      margin: 15px 0 5px;
      color: var(--totals-color);
    }
    
    .table-header {
      font-weight: bold;
      margin: 15px 0 5px;
      color: var(--table-header-color);
      font-size: 1.2em;
    }
    
    @media (max-width: 768px) {
      .charts-container {
        flex-direction: column;
      }
      
      .chart-container {
        width: 100%;
      }
      
      .filters {
        flex-direction: column;
        gap: 15px;
      }
      
      .table-responsive {
  overflow-x: auto;
  margin-bottom: 15px;
}

      
@media (max-width: 768px) {
  table th, table td {
    padding: 6px 4px;
    font-size: 0.9em;
  }
}
    }
  </style>
</head>
<body>
  <div class="dashboard-container">   
    <h1>
       Earnings Dashboard 
    </h1>
    

      <div class="divider"></div>
    
    <div class="filters">
      <div class="filter-group">
        <label for="monthFilter">Month-Year:</label>
        <select id="monthFilter">
          <option value="ALL">ALL</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="searchInput">Search Item or Category:</label>
        <input type="text" id="searchInput" placeholder="Search...">
      </div>

      <div class="filter-group">
        <label>Category:</label>
        <div id="categoryFilters" class="radio-group">
          <label><input type="radio" name="category" value="ALL" checked> ALL</label>
        </div>
      </div>
    </div>

    <div class="totals" id="totalsDisplay"></div>

    <div class="divider"></div>

    
    <div class="charts-container">
      <div class="chart-container">
        <canvas id="patientCountChart"></canvas>
      </div>
      <div class="chart-container">
        <canvas id="earningsChart"></canvas>
      </div>
    </div>
    
    <div class="divider"></div>

    
    <div class="table-header">Logbook</div>
    
    <table id="dataTable">
      <thead>
        <tr>
          <th>Date</th>
          <th>Clinic</th>
          <th>Type</th>
          <th>Count</th>
          <th>Price</th>
          <th>Earned</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    // Configuration
    const CONFIG = {
      csvUrl: "https://docs.google.com/spreadsheets/d/e/2PACX-1vSmajYkga40XsAJNrKvXEFRh8TNCG_-ojL67wytOlvLJqZJdYrquS4IxikIQi84T95ftbq48sell78r/pub?gid=1192759857&single=true&output=csv",
      categoryColors: {
        'The Clinic': '#FFBF65',
        'Aqua Physio': '#BDD7BF'
      },
      chartColors: [
        '#3366CC', '#DC3912', '#FF9900', '#109618', '#990099',
        '#3B3EAC', '#0099C6', '#DD4477', '#66AA00', '#B82E2E',
        '#316395', '#994499', '#22AA99', '#AAAA11', '#6633CC',
        '#E67300', '#8B0707', '#651067', '#329262', '#5574A6'
      ],
      labelSettings: {
        font: {
          family: 'Arial Narrow',
          size: 9
        },
        color: '#444444' // dark grey
      }
    };

    // State
    const STATE = {
      rawData: [],
      filteredData: [],
      charts: {
        patientCount: null,
        earnings: null
      }
    };

    // DOM Elements
    const DOM = {
      monthFilter: document.getElementById('monthFilter'),
      searchInput: document.getElementById('searchInput'),
      categoryFilters: document.getElementById('categoryFilters'),
      dataTableBody: document.querySelector('#dataTable tbody'),
      totalsDisplay: document.getElementById('totalsDisplay'),
      patientCountChart: document.getElementById('patientCountChart'),
      earningsChart: document.getElementById('earningsChart')
    };

    // Initialize
    document.addEventListener('DOMContentLoaded', initialize);

    async function initialize() {
      await fetchData();
      setupEventListeners();
      populateFilters();
      applyFilters();
      renderCharts();
    }

    function setupEventListeners() {
      DOM.monthFilter.addEventListener('change', debounce(applyFilters, 250));
      DOM.searchInput.addEventListener('input', debounce(applyFilters, 250));
      DOM.categoryFilters.addEventListener('change', applyFilters);
    }

    async function fetchData() {
      try {
        const response = await fetch(CONFIG.csvUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.text();
        parseCSV(data);
      } catch (error) {
        console.error('Error fetching data:', error);
        alert('Failed to load data. Please check your connection and try again.');
      }
    }

    function parseCSV(data) {
      const lines = data.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.trim());

      STATE.rawData = lines.slice(1).map(line => {
        const values = line.split(',');
        const entry = {};
        headers.forEach((header, index) => {
          entry[header] = values[index] ? values[index].trim() : '';
        });
        return entry;
      });
    }

    function populateFilters() {
      // Extract unique values for filters
      const months = new Set();
      const categories = new Set();

      STATE.rawData.forEach(row => {
        months.add(row['Month Year'] || row['Month-Year']);
        categories.add(row['Category']);
      });

      // Sort months chronologically
      const sortedMonths = Array.from(months).sort();
      
      // Populate month filter
      sortedMonths.forEach(month => {
        const option = document.createElement('option');
        option.value = month;
        option.textContent = month;
        DOM.monthFilter.appendChild(option);
      });

      // Populate category filters
      Array.from(categories).sort().forEach(category => {
        const label = document.createElement('label');
        label.innerHTML = `<input type="radio" name="category" value="${category}"> ${category}`;
        DOM.categoryFilters.appendChild(label);
      });
    }

    function applyFilters() {
      const monthValue = DOM.monthFilter.value;
      const searchValue = DOM.searchInput.value.toLowerCase();
      const categoryRadios = document.getElementsByName('category');
      let selectedCategory = 'ALL';
      
      categoryRadios.forEach(radio => {
        if (radio.checked) selectedCategory = radio.value;
      });

      STATE.filteredData = STATE.rawData.filter(row => {
        const monthKey = row['Month Year'] ? 'Month Year' : 'Month-Year';
        const matchesMonth = monthValue === 'ALL' || row[monthKey] === monthValue;
        const matchesSearch = (row['Item Name'] || '').toLowerCase().includes(searchValue) || 
                              (row['Category'] || '').toLowerCase().includes(searchValue);
        const matchesCategory = selectedCategory === 'ALL' || row['Category'] === selectedCategory;
        
        return matchesMonth && matchesSearch && matchesCategory;
      });

      updateTable();
      updateTotals();
      updateCharts();
    }

    function updateTable() {
      // Clear table
      DOM.dataTableBody.innerHTML = '';
      
      if (STATE.filteredData.length === 0) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="6" style="text-align: center">No data matches your filters</td>`;
        DOM.dataTableBody.appendChild(tr);
        return;
      }
      
      // Create document fragment for better performance
      const fragment = document.createDocumentFragment();
      
      // Add rows
      STATE.filteredData.forEach(row => {
        const perPatientTotal = parseFloat(row['Per patient total']) || 0;
        const categoryColor = CONFIG.categoryColors[row['Category']] || '';
        
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${row['Date Convert']}</td>
          <td style="background-color: ${categoryColor}">${row['Category']}</td>
          <td>${row['Item Name']}</td>
          <td>${row['Quantity']}</td>
          <td>${formatCurrency(row['price'])}</td>
          <td class="${perPatientTotal < 0 ? 'negative' : ''}">${formatCurrency(perPatientTotal)}</td>
        `;
        fragment.appendChild(tr);
      });
      
      DOM.dataTableBody.appendChild(fragment);
    }

    function updateTotals() {
  let grossTotal = 0;
  const categoryTotals = {};
  const itemTotals = {};
  const groupTotals = {};

  // Calculate totals
  STATE.filteredData.forEach(row => {
    const numericValue = parseFloat(row['Per patient total']) || 0;
    grossTotal += numericValue;

    const cat = row['Category'];
    const item = row['Item Name'];
    
    categoryTotals[cat] = (categoryTotals[cat] || 0) + numericValue;
    itemTotals[item] = (itemTotals[item] || 0) + numericValue;
    
    // Extract first word for grouping
    const firstWord = item.split(' ')[0];
    groupTotals[firstWord] = (groupTotals[firstWord] || 0) + numericValue;
  });

  const sortedCategories = Object.keys(categoryTotals).sort();
  const sortedGroups = Object.keys(groupTotals).sort();

  // Generate HTML for categories table
  const categoriesTableHTML = `
    <div class="totals-header">Earnings per Category</div>
    <div class="table-responsive">
      <table>
        <thead>
          <tr>
            <th>Gross Total</th>
            ${sortedCategories.map(cat => `<th>${cat}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>${formatCurrency(grossTotal)}</td>
            ${sortedCategories.map(cat => `<td>${formatCurrency(categoryTotals[cat])}</td>`).join('')}
          </tr>
        </tbody>
      </table>
    </div>
  `;

  // Generate HTML for groups table
  // For many groups, use a vertical layout that's more mobile-friendly
  let groupsTableHTML = `
    <div class="totals-header">Earnings per Clinic Item (Grouped)</div>
    <div class="table-responsive">
  `;
  
  if (sortedGroups.length > 8) {
    // Vertical layout for many groups (better for mobile)
    groupsTableHTML += `
      <table>
        <thead>
          <tr>
            <th>Item Group</th>
            <th>Earnings</th>
          </tr>
        </thead>
        <tbody>
          <tr style="font-weight: bold;">
            <td>Gross Total</td>
            <td>${formatCurrency(grossTotal)}</td>
          </tr>
          ${sortedGroups.map(group => `
            <tr>
              <td>${group}</td>
              <td>${formatCurrency(groupTotals[group])}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
  } else {
    // Horizontal layout for fewer groups
    groupsTableHTML += `
      <table>
        <thead>
          <tr>
            <th>Gross Total</th>
            ${sortedGroups.map(group => `<th>${group}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>${formatCurrency(grossTotal)}</td>
            ${sortedGroups.map(group => `<td>${formatCurrency(groupTotals[group])}</td>`).join('')}
          </tr>
        </tbody>
      </table>
    `;
  }
  
  groupsTableHTML += `</div>`;
  
  // Update the DOM
  DOM.totalsDisplay.innerHTML = categoriesTableHTML + groupsTableHTML;
}
    
    function formatCurrency(value) {
      const number = parseFloat(value);
      return isNaN(number) ? 'SGD 0.00' : `SGD ${number.toLocaleString('en-SG', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    }

    function renderCharts() {
      const monthlyData = processDataForCharts();
      renderPatientCountChart(monthlyData);
      renderEarningsChart(monthlyData);
    }
    
    function updateCharts() {
      if (STATE.charts.patientCount) {
        STATE.charts.patientCount.destroy();
      }
      if (STATE.charts.earnings) {
        STATE.charts.earnings.destroy();
      }
      renderCharts();
    }

    function processDataForCharts() {
      const monthlyItemCount = {};
      const monthlyCategoryEarnings = {};
      const allMonths = new Set();
      const itemSet = new Set();
      const categorySet = new Set();
       
      STATE.rawData.forEach(row => {
        const month = row['Month Year'] || row['Month-Year'];
        const item = row['Item Name'];
        const category = row['Category'];
        const value = parseFloat(row['Per patient total']) || 0;
        const quantity = parseInt(row['Quantity'], 10) || 1;

        allMonths.add(month);
        itemSet.add(item);
        categorySet.add(category);

        // Initialize if needed
        if (!monthlyItemCount[month]) monthlyItemCount[month] = {};
        if (!monthlyItemCount[month][item]) monthlyItemCount[month][item] = 0;
        
        if (!monthlyCategoryEarnings[month]) monthlyCategoryEarnings[month] = {};
        if (!monthlyCategoryEarnings[month][category]) monthlyCategoryEarnings[month][category] = 0;
        
        // Add values
        monthlyItemCount[month][item] += quantity;
        monthlyCategoryEarnings[month][category] += value;
      });

      return {
        months: Array.from(allMonths).sort(),
        items: Array.from(itemSet).sort(),
        categories: Array.from(categorySet).sort(),
        itemCounts: monthlyItemCount,
        categoryEarnings: monthlyCategoryEarnings
      };
    }

    function renderPatientCountChart(data) {
      const patientCountData = {
        labels: data.months,
        datasets: data.items.map((item, i) => ({
          label: item,
          data: data.months.map(month => (data.itemCounts[month] && data.itemCounts[month][item]) || 0),
          backgroundColor: CONFIG.chartColors[i % CONFIG.chartColors.length],
          categoryPercentage: 0.8,
          barPercentage: 0.9
        }))
      };

      STATE.charts.patientCount = new Chart(DOM.patientCountChart, {
        type: 'bar',
        data: patientCountData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                font: { size: 10 },
                boxWidth: 10,
                boxHeight: 10
              }
            },
            title: { 
              display: true, 
              text: 'Patient Count per Item by Month', 
              color: '#2a52be', 
              font: { size: 14 } 
            },
            datalabels: {
              display: function(context) {
                return context.dataset.data[context.dataIndex] > 0;
              },
              anchor: 'end',
              align: 'top',
              offset: 0,
              color: CONFIG.labelSettings.color,
              font: CONFIG.labelSettings.font,
              formatter: function(value) {
                return value;
              }
            }
          },
          scales: {
            x: { stacked: false },
            y: { 
              stacked: false,
              beginAtZero: true,
              grace: '10%' // Add space at the top for labels
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }

    function renderEarningsChart(data) {
      const earningsData = {
        labels: data.months,
        datasets: data.categories.map((cat, i) => ({
          label: cat,
          data: data.months.map(month => (data.categoryEarnings[month] && data.categoryEarnings[month][cat]) || 0),
          backgroundColor: CONFIG.chartColors[i % CONFIG.chartColors.length],
          categoryPercentage: 0.8,
          barPercentage: 0.9
        }))
      };

      STATE.charts.earnings = new Chart(DOM.earningsChart, {
        type: 'bar',
        data: earningsData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                font: { size: 11 },
                boxWidth: 10,
                boxHeight: 10
              }
            },
            title: { 
              display: true, 
              text: 'Monthly Earnings per Category', 
              color: '#2a52be', 
              font: { size: 14 } 
            },
            datalabels: {
              display: function(context) {
                return context.dataset.data[context.dataIndex] > 0;
              },
              anchor: 'center',
              align: 'center',
              rotation: -90,
              color: '#fff',
              font: { size: 10 },
              formatter: function(value) {
                return value.toLocaleString('en-SG', {
                  minimumFractionDigits: 0,
                  maximumFractionDigits: 0
                });
              }
            }
          },
          scales: {
            x: { stacked: true },
            y: {
              stacked: true,
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return 'SGD ' + value.toLocaleString('en-SG', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                  });
                }
              }
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }
    
    // Utility Functions
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
  </script>
</body>
</html>
